\documentclass{article}
\usepackage{packages}

\title{Коллоквиум по Дискретной математике, 2 курс}
\author{Залялов Александр, @bcategorytheory,\\  Солодовников Никита, @applied\_memes, \\ Шморгунов Александр, @Owlus \\
Виноградова Дарья, @orange\_to\_the\_wall, \\ Никитин Роман, @pomo\_mondreganto}
\date{}

\begin{document}

    \maketitle

    \section*{Важные объявления.}
    \subsection*{Билет №6.} В авторском решении билета №6 была обнаружена ошибка. \sout{Коллоквиум
    объявляется нерейтинговым.} Рекомендуется посмотреть изменения и осознать, что было не так.
    
    \subsection*{Билет №17.} В авторском решении была обнаружена лажа. Билет исправлен, рекомендуется его перечитать.

    \tableofcontents

    \clearpage

    \section{Определение вычислимой частичной функции из $\mathbb{N}$ в $\mathbb{N}$.
    Счётность семейства частичных вычислимых функций, и существование невычислимых функций.
    Разрешимые и перечислимые подмножества $\mathbb{N}$. Счётность семейства перечислимых множеств,
    существование неперечислимых множеств.}

    Здесь не даётся формального определения алгоритма. В нашем случае ``алгоритм'' --- некоторый
    чёрный ящик, принимающий на вход конструктивный объект (натуральное число или же объект, который
    можно закодировать как натуральное число), производящий некоторый результат (также конструктивный
    объект), а также работающий по шагам (некоторые атомарные действия вроде сложения).

    Rule of thumb для вопроса ``Алгоритм ли это?'' --- можно написать как программу на каком-нибудь
    языке программирования.

    \begin{definition}
        Функция $f: \mathbb{N} \to \mathbb{N}$ называется \textit{частичной}, если $\operatorname{Dom} f \subseteq \mathbb{N}$.
    \end{definition}

    \begin{definition}
        Функция $f: \mathbb{N} \to \mathbb{N}$ называется \textit{тотальной}, если $\operatorname{Dom} f = \mathbb{N}.$
    \end{definition}

    \begin{definition}
        Алгоритм $\mathcal{A}$ \textit{вычисляет} частичную функцию $f: \mathbb{N} \to \mathbb{N}$, если
        $$
            \begin{cases}
                \mathcal{A}(x) = f(x), & \text{если $x \in \operatorname{Dom} f$,}\\
                \mathcal{A}(x) \text{ не определено} & \text{иначе.}
            \end{cases}
        $$
    \end{definition}

    \begin{definition}
        Частичная функция $f: \mathbb{N} \to \mathbb{N}$ называется \textit{вычислимой}, если существует
        алгоритм, её вычисляющий.
    \end{definition}

    \begin{statement}
        Множество частичных вычислимых функций не более, чем счётно.
    \end{statement}
    \begin{proof}
        Действительно, всякой вычислимой функции можно поставить в соответствие некоторый алгоритм,
        причём различные функции вычисляются различными алгоритмами. Алгоритм --- это программа,
        то есть конечная строка. Конечных строк (а следовательно, алгоритмов) всего лишь счётное число.
        Существует инъекция из множества вычислимых функций в множество алгоритмов, значит, количество
        вычислимых функций не более, чем счётно.
    \end{proof}

    \begin{theorem}
        Существуют невычислимые функции $f: \mathbb{N} \to \mathbb{N}$.
    \end{theorem}
    \begin{proof}
        Мощность множества вычислимых функций меньше мощности множества всех функций из $\mathbb{N}
        \to \mathbb{N}$, а значит, его дополнение не пусто.
    \end{proof}

    \begin{definition}
        Множество $A \subseteq \mathbb{N}$ называется \textit{разрешимым}, если существует алгоритм, вычисляющий
        его характеристическую функцию $\chi_A(x)$, то есть функцию такую, что
        $$
            \chi_A(x) =
            \begin{cases}
                1, & \text{если $x \in A$,}\\
                0 & \text{иначе.}
            \end{cases}
        $$
    \end{definition}

    \begin{definition}
        Множество $A \subseteq \mathbb{N}$ называется \textit{перечислимым}, если существует
        алгоритм (не принимающий никаких входных данных), который выводит последовательность $a_n$
        такую, что множество всех элементов этой последовательности равно $A$.
    \end{definition}

    \begin{statement}
        Множество перечислимых подмножеств $\mathbb{N}$ не более, чем счётно.
    \end{statement}
    \begin{proof}
        Всякому перечислимому множеству соответствует алгоритм, его перечисляющий, причём различные множества
        перечисляются различными алгоритмами. Отсюда следует, что мощность множества перечислимых множеств не
        превосходит мощности множества алгоритмов, которое, в свою очередь, является счётным.
    \end{proof}

    \begin{theorem}
        Существуют неперечислимые множества $A \subseteq \mathbb{N}$.
    \end{theorem}
    \begin{proof}
        Множество перечислимых множеств имеет мощность меньшую, чем $2^\mathbb{N}$. Значит, его дополнение
        не пусто.
    \end{proof}

    \section{Эквивалентные определения перечислимости: полуразрешимость, область определения
    вычислимой функции, множество значений вычислимой функции.}

    \begin{definition}
        Множество $A \subseteq \mathbb{N}$ называется \textit{полуразрешимым}, если существует алгоритм,
        вычисляющий его полухарактеристическую функцию $\xi_A(x)$, то есть функцию такую, что
        $$
            \xi_A(x) =
            \begin{cases}
                1, & \text{если $x \in A$,}\\
                \text{не определено} & \text{иначе.}
            \end{cases}
        $$
    \end{definition}

    \begin{theorem}
        Следующие утверждения эквивалентны:
        \begin{enumerate}
            \item Множество $A$ перечислимо.
            \item Множество $A$ полуразрешимо.
            \item Существует частичная вычислимая функция $f: \mathbb{N} \to \mathbb{N}$ такая, что
                $A = \operatorname{Dom} f$.
            \item Существует частичная вычислимая функция $f: \mathbb{N} \to \mathbb{N}$ такая, что
                $A = \operatorname{Ran} f$.
        \end{enumerate}
    \end{theorem}

    \begin{proof}
        Чтобы показать эквивалентность всех этих утверждений, докажем несколько импликаций.

        $(1) \implies (2)$

        Множество $A$ перечислимо, докажем его полуразрешимость.

        Модифицируем алгоритм $\mathcal{A}$ перечисления множества $A$ следующим образом: если для входа $x$
        при перечислении мы встретили $x$, вернём ответ $1$, иначе продолжим работу, ничего не возвращая.
        Так как в последовательности, получаемой алгоритмом, рано или поздно встретится каждый из
        элементов $A$, положительный ответ будет дан за конечное число шагов. В случае, если $x
        \not\in A$, алгоритм зациклится без вывода, что вполне устраивает нас в рамках нашей задачи.

        $(2) \implies (3)$

        Множество $A$ полуразрешимо, докажем, что найдётся вычислимая функция, для которой $A$ ---
        область определения.

        Этой частичной вычислимой функцией был \sout{Альберт Эйнштейн} $\xi_A(x)$. Действительно,
        знаем, что $\xi_A(x)$ вычислима, а $\operatorname{Dom} \xi_A = A$. Значит, мы
        нашли искомую функцию.

        $(3) \implies (4)$

        Множество $A$ является областью определения некоторой вычислимой функции $f$, докажем, что
        оно также является областью значений некоторой другой вычислимой функции.

        Определим функцию $g(x)$:
        $$
            g(x) =
            \begin{cases}
                x, & \text{если } x \in \operatorname{Dom} f,\\
                \text{не определено} & \text{иначе.}
            \end{cases}
        $$

        Эта функция вычислима. Алгоритм, её вычисляющий, должен попытаться вычислить $f(x)$ и затем
        просто вывести $x$. Кроме того, $\operatorname{Ran} g = \operatorname{Dom} f$, а значит, мы
        нашли искомую функцию.

        $(4) \implies (1)$

        Множество $A$ является областью значений некоторой вычислимой функции, докажем его
        перечислимость.

        Известно, что существует алгоритм $\mathcal{F}$, вычисляющий функцию $f$, область значений
        которой совпадает с $A$. Чтобы перечислить элементы множества $A$, будем бесконечно
        производить итерации следующего вида: на $n$-той итерации запустим по очереди на $n$
        шагов $\mathcal{F}(i)$ для каждого $0 \leqslant i \leqslant n$. Таким образом, для всех $i$
        алгоритм $\mathcal{F}(i)$ будет рано или поздно запущен на число шагов, необходимое для
        завершения.  Значит, на всех $x$ из $\operatorname{Dom} f$ мы вычислим (и выведем) $f(x)$.
        Таким образом будут выведены все элементы $\operatorname{Ran} f$, равного $A$.

        Из каждого утверждения следуют все остальные. Значит, утверждения эквивалентны.
    \end{proof}

    \section{Теорема Поста. Теорема о графике.}

    \paragraph{Теорема Поста.} \label{Post} Множества $A$ и $\mathbb{N} \setminus A$ перечислимы
    тогда и только тогда, когда $A$ разрешимо.

    \begin{proof} \

        $\implies$

        Перечислимость множества эквивалентна его полуразрешимости. Будем использовать алгоритмы
        $\mathcal{A}$ и $\mathcal{B}$, вычисляющие $\xi_{A}(x)$ и $\xi_{\mathbb{N} \setminus A}(x)$
        соответственно.

        Алгоритм $\mathcal{C}$, находящий $\chi_A(x)$, будет по очереди запускать $\mathcal{A}(x)$ и
        $\mathcal{B}(x)$ на некоторое число шагов. Как только один из этих алгоритмов завершится, можно
        будет дать ответ: если $x \in A$, вернуть $1$, в противном случае вернуть $0$.

        Докажем корректность построенного алгоритма. Во-первых, он действительно даёт правильный
        ответ на всех $x \in \mathbb{N}$, а во-вторых, всегда завершается, так как всякое
        натуральное число лежит либо в множестве $A$, либо в его дополнении. Оба вспомогательных
        алгоритма могут при необходимости отработать бесконечное число шагов, значит, если какой-то
        из них завершается на данном входе, он завершится.

        $\impliedby$

        Если множество разрешимо, его дополнение также разрешимо. Разрешимость влечёт
        перечислимость.
    \end{proof}

    \begin{definition}
        Пусть задана функция $f$. Множество $\Gamma_f = \{(x, f(x)) \mid x \in \operatorname{Dom} f\}$
        называется \textit{графиком} функции $f$.
    \end{definition}

    \paragraph{Теорема о графике.} Функция $f$ вычислима тогда и только тогда, когда $\Gamma_f$
    перечислимо.
    \begin{proof}\

        $\implies$

        Умея вычислять функцию $f$, хотим перечислить $\Gamma_f$.

        Будем бесконечно производить итерации следующего вида: на $n$-той итерации попытаемся
        вычислить $f(x)$ для всех $0 \leqslant x \leqslant n$ не более, чем за $n$ шагов.
        Если удастся, выведем пару $(x, f(x))$ в противном случае остановим вычисление $f(x)$
        и перейдём к следующему $i$. Для каждого $x \in \operatorname{Dom} f$ рано или поздно мы
        произведём достаточное число шагов, чтобы вычислить $f(x)$, так как алгоритм, вычисляющий
        $f(x)$, должен завершаться за конечное число шагов. Значит, $\Gamma_f$ таким образом
        действительно будет перечислено.

        $\impliedby$

        Умея перечислять $\Gamma_f$, хотим вычислить $f(x)$.

        Будем перечислять $\Gamma_f$, пока не найдём пару, в которой первый элемент равен $x$.
        Действительно, если функция определена на $x$, то такая пара найдётся в $\Gamma_f$,
        а значит, будет выведена алгоритмом его перечисления за конечное число шагов. Далее просто
        выведем второй элемент этой пары и завершим работу.

    \end{proof}

    \section{Универсальные вычислимые функции (нумерации) для семейства частичных вычислимых
    функций натурального аргумента. Несуществование универсальной вычислимой функции для
    семейства тотальных вычислимых функций натурального аргумента (диагональное рассуждение).
    Главные универсальные функции.}

    Известно, что множество частичных вычислимых функций счётно. Значит, все эти функции можно
    каким-то способом занумеровать.

    \begin{definition}
        Пусть $\varphi_n$ --- последовательность вычислимых частичных функций. Такая
        последовательность называется \textit{универсальной нумерацией}. Функция $f:
        \mathbb{N} \times \mathbb{N} \to \mathbb{N}$ такая, что $f(n, x) = \varphi_n(x)$, называется
        \textit{универсальной функцией}.
    \end{definition}

    \begin{theorem}
        Существует \underline{вычислимая} нумерация (универсальная функция).
    \end{theorem}

    \begin{proof}
        Определим следующий порядок на двоичных словах: если слово $a$ короче слова $b$, $a \prec
        b$, если наоборот --- $b \prec a$, в случае же равной длины будем сравнивать слова
        лексикографически. Последовательность двоичных слов в таком порядке будет выглядеть как
        $\{\bot, 0, 1, 00, 01, 10, 11, \ldots\}$. Таким образом множество окажется вполне упорядоченным.
        Теперь каждому натуральному числу можно поставить в соответствие некоторое двоичное слово.

        Без ограничения общности будем считать, что алгоритм можно записать некоторым двоичным
        словом.

        Определим теперь функцию $f(n, x)$ следующим образом: интерпретируем двоичное слово
        с номером $n$ (в нашем порядке $\prec$) как код (запись машины Тьюринга, программу на C, whatever)
        для алгоритма $\mathcal{A}$, и положим $f(n, x) = \mathcal{A}(x)$. Если двоичное слово
        с номером $n$ не является корректной записью алгоритма, будем считать, что $f(n, x)$ не
        определена для всех $x$.

        Описанная функция вычислима. Она также является универсальной, так как пробегает по всем
        возможным алгоритмам (и, как следствие, всем возможным вычислимым функциям). Значит, мы
        построили вычислимую универсальную функцию.
    \end{proof}

    Может показаться, что универсальная функция может существовать и для семейства тотальных
    вычислимых функций. Однако, это неверно.

    \begin{theorem}
        Не существует вычислимой нумерации (универсальной функции) для семейства тотальных
        вычислимых функций.
    \end{theorem}
    \begin{proof}
        Допустим, что существует вычислимая нумерация $\psi_n$ тотальных вычислимых функций. Значит,
        будет тотальной и вычислимой функция следующего вида
        $$
            f(x) = \psi_x(x) + 1.
        $$

        Так как функция $f$ тотальна и вычислима, должно найтись $n$ такое, что $\psi_n(x) = f(x)$.
        Однако, если поставить $x = n$:
        $$
            \psi_n(n) = f(n) = \psi_n(n) + 1.
        $$

        Произошло противоречие \footnote{Такая конструкция не будет приводить к противоречию,
        если говорить о частичных функциях, а не тотальных. Действительно, построенная нами
        функция $f = \varphi_n$ просто не будет определена в точке $n$.}\dots

    \end{proof}

    \begin{definition}
        Нумерация $\varphi$ называется \textit{главной}, если для любой вычислимой частичной
        функции $V(n, x)$ существует тотальная вычислимая функция $s(n)$ такая, что $V(n, x)
        = \varphi_{s(n)}(x)$.
    \end{definition}

    \begin{theorem}
        Существует главная нумерация (универсальная функция).
    \end{theorem}

    \begin{proof}
        Рассмотрим построенную выше нумерацию. Для функции $V(n, x)$ построим алгоритм $\mathcal{S}(m)$,
        который ``вшивает'' в алгоритм $\mathcal{V}(n, x)$, вычисляющий $V(n, x)$, константу $m$ вместо
        переменной $n$. Такой алгоритм, очевидно, всегда будет завершаться. Значит, он вычисляет
        некоторую тотальную функцию $s(n)$.
    \end{proof}

    \section{Вычислимая функция, не имеющая тотального вычислимого продолжения. Перечислимое неразрешимое
    множество. Неразрешимость \\ проблемы применимости.}

    \begin{definition}
        Функция $g$ является \textit{продолжением} функции $f$, если $\operatorname{Dom} f \subset
        \operatorname{Dom} g$ и $\forall x \in \operatorname{Dom} f \; g(x) = f(x)$.
    \end{definition}

    \begin{theorem}
        Существует вычислимая частичная функция, не имеющая всюду определённого продолжения.
    \end{theorem}
    \begin{proof}
        Определим функцию $f$:
        $$
            f(x) = \varphi_x(x) + 1.
        $$

        Пусть мы вычислимо продолжили функцию $f$ функцией $\varphi_n$ (продолжение вычислимо, а потому
        будет присутствовать в главной нумерации). Запишем уравнение:
        $$
            \varphi_x(x) + 1 = \varphi_n(x).
        $$

        Это уравнение, вообще говоря, неверно, так как левая часть может быть не определена, но при
        этом при подстановке $x = n$ получаем слева вполне определённое выражение (напомню,
        $\varphi_n$ всюду определена), а вместе с ним и противоречие:
        $$
            \varphi_n(n) + 1 = \varphi_n(n).
        $$

        Значит, для функции $f$ не существует всюду определённого вычислимого продолжения.
    \end{proof}

    \begin{theorem}
        Множество $A = \{x \mid \varphi_x(x) \text{ определено}\}$ неразрешимо.
    \end{theorem}
    \begin{proof}
        Вернёмся вновь к нашей любимой функции $f$:
        $$
            f(x) = \varphi_x(x) + 1.
        $$

        Продолжим эту функцию самым простым способом --- везде вне её области определения её
        продолжение будет равно нулю. Нетрудно было бы реализовать это продолжение, умея разрешать
        множество $A$: просто вычислим $\varphi_x(x) + 1$, если это значение определено, и вернём ноль
        иначе.

        Однако мы уже знаем, что продолжение функции $f$ не может быть вычислимым. Значит,
        вычислимость $\chi_A$ приводит к противоречию.
    \end{proof}

    \begin{definition}
        Задача разрешения множества $\{(n, x) \mid \varphi_n(x) \text{ определено}\}$ называется
        \textit{проблемой остановки (применимости)}.
    \end{definition}

    \begin{theorem}
        \textit{Проблема остановки} неразрешима.
    \end{theorem}
    \begin{proof}
        Пусть $\chi_A$ вычисляется алгоритмом $\mathcal{A}$. Запустив $\mathcal{A}(x, x)$, можно
        разрешить множество $\linebreak{\{x \mid \varphi_x(x) \text{ определено}\}}$, для которого уже
        доказана неразрешимость.
    \end{proof}

    \section{Теорема Поста. Существование перечислимого множества, дополнение которого неперечислимо.
    Перечислимые неотделимые множества.}

    \textbf{Теорема Поста} была доказана \hyperref[Post]{здесь}.

    \begin{theorem}
        Существует перечислимое множество с неперечислимым дополнением.
    \end{theorem}
    \begin{proof}
        Уже знакомое нам множество $\{x \mid \varphi_x(x) \text{ определено}\}$ является
        неразрешимым. Однако же, это множество очевидно полуразрешимо, а значит, и перечислимо.

        Предположим теперь, что дополнение данного множества перечислимо. В таком случае, согласно
        теореме Поста, само множество разрешимо. Противоречие.
    \end{proof}

    \begin{definition}
        Множества $A, B$ называются \textit{отделимыми}, если существует множество $C$ такое, что $A
        \subseteq C$ и $B \cap C = \varnothing$.
    \end{definition}

    \begin{theorem}
        Существуют непересекающиеся перечислимые множества, которые нельзя отделить разрешимым
        множеством.
    \end{theorem}
    \begin{proof}
        Рассмотрим множества $A = \{x \mid \varphi_x(x) = 0\}$ и $B = \{x \mid \varphi_x(x) = 1
        \footnote{Раньше здесь можно было увидеть запись $\varphi_x(x) = 42$, однако, авторы
        конспекта выяснили, что в таком случае противоречия нет. Вопрос на понимание: почему множество
        $\{x \mid \varphi_x(x) = 42\}$ не приводит к противоречию? (подсказка: приводит, но не для
        всех возможных значений $\varphi_n(n)$)}\} $.
        Они, очевидно, перечислимы и не пересекаются.

        Допустим, существует разрешимое $C$, отделяющее $A$ и $B$. Пусть оно содержит в себе
        множество $A$. Тогда:

        $$
            \chi_C(x) =
            \begin{cases}
                1, & \text{если $\varphi_x(x) = 0$,}\\
                0, & \text{если $\varphi_x(x) = 1$,}\\
                \text{и что-то ещё на других числах.}
            \end{cases}
        $$

        $\chi_C$ вычислима. Значит, $\exists n \ \chi_C(x) = \varphi_n(x)$ Но пусть тогда $x = n$.
        Получаем:

        $$
            \varphi_n(n) =
            \begin{cases}
                1, & \text{если $\varphi_n(n) = 0$,}\\
                0, & \text{если $\varphi_n(n) = 1$,}\\
                \text{и что-то ещё на других числах.}
            \end{cases}
        $$

        Получили противоречие: $\phi_n(n)$ обязана быть определена (так как это характеристическая
        функция) и также обязана принимать одно из значений $1$ и $0$.
    \end{proof}

    \section{Сводимости: m-сводимость и Тьюрингова сводимость. Свойства. Полные перечислимые множества.}

    \begin{definition}
        Множество $A$ \textit{m-сводится} к множеству $B$, если существует тотальная вычислимая
        функция $f$ такая, что $\forall x \ x \in A \iff f(x) \in B$. Обозначается как $A
        \leqslant_m B$.
    \end{definition}

    m-сводимость позволяет построить алгоритм разрешения множества $A$, если есть алгоритм
    разрешения множества $B$. Строго говоря, $\chi_A(x) = \chi_B(f(x))$.

    Свойства m-сводимости:
    \begin{itemize}
        \item $A \leqslant_m A$ (рефлексивность),
        \item $A \leqslant_m B \wedge B \leqslant_m C \implies A \leqslant_m C$ (транзитивность),
        \item
        $
        \left.\begin{aligned}
                &B \text{ разрешимо}\\
                &A \leqslant_m B
        \end{aligned}\right\}
        \implies A \text{ разрешимо},
        $
        \item
        $
        \left.\begin{aligned}
                &A \text{ неразрешимо}\\
                &A \leqslant_m B
        \end{aligned}\right\}
        \implies B \text{ неразрешимо}.
        $
    \end{itemize}

    \begin{definition}
        Множество $A$ \textit{T-сводится} (сводится по Тьюрингу) к множеству $B$, если при помощи
        алгоритма вычисления $\chi_B$ (не обязательно существующего) можно вычислить $\chi_A$.
        Обозначается как $A \leqslant_T B$ \footnote{Это --- старая добрая сводимость из курса
        алгоритмов. Классы задач P и NP машут ручкой.}.
    \end{definition}

    Тьюринова сводимость обладает теми же свойствами, что и m-сводимость. Однако же, $A \leqslant_m
    B \implies A \leqslant_T B$, а обратное утверждение неверно.

    Тьюрингова сводимость обладает ещё одним свойством: $A \leqslant_T \mathbb{N} \setminus A$.
    Однако же данное утверждение не будет верно для m-сводимости. К примеру, множество $\mathbb{N}$
    не может быть m-сведено к своему дополнению.

    \begin{definition}
        Перечислимое множество, к которому m-сводится любое другое перечислимое множество, называется
        \textit{полным перечислимым множеством}.
    \end{definition}
    \begin{theorem}
        Существует полное перечислимое множество.
    \end{theorem}
    \begin{proof}
        Рассмотрим множество $A = \{(n, x) \mid \varphi_n(x) \text{ определено}\}$. Заметим, что оно
        перечислимо.

        Пусть мы хотим свести некоторое перечислимое множество $B$ к множеству $A$. Знаем, что
        в силу перечислимости существует вычислимая частичная функция $f$ такая, что $B
        = \operatorname{Dom} f$. Эта функция должна присутствовать в универсальной нумерации. Пусть
        это $\varphi_n$. Тогда для того, чтобы проверить принадлежность $x \in B$, достаточно проверить
        принадлежность $(n, x) \in A$. Сводящая функция в данном случае выглядит как $m(x) = (n,
        x)$.
    \end{proof}

    \section{Теорема Клини о неподвижной точке.}

    \begin{theorem}
        Для всякой тотальной вычислимой функции $f$ и главной нумерации $\varphi_n$ найдётся $n$
        такое, что $\varphi_n = \varphi_{f(n)}$ \footnote{Неформально: существует программа, которая
        может напечатать свой код.}.
    \end{theorem}

    \begin{proof}
        Педагогический трюк для лучшего запоминания: сначала попытаемся доказать ложное утверждение
        о том, что у всякой тотальной вычислимой функции есть неподвижная точка, то есть число $n$
        такое, что $n = f(n)$.

        Функция $f$ вычислима, функция $\varphi_x(x)$ вычислима, значит, вычислима их композиция. То
        есть, существует $m$ такое, что
        $$
            f(\varphi_x(x)) = \varphi_m(x).
        $$

        Подставляя $x = m$, получаем
        $$
            f(\varphi_m(m)) = \varphi_m(m),
        $$
        то есть $n = \varphi_m(m)$.

        И всё бы было хорошо, если бы $\varphi_m(m)$ было всегда определено. Но вернёмся в суровую
        реальность и докажем истинное утверждение теоремы Клини.

        Вместо равенства чисел нужно рассматривать эквивалентность следующего вида: $n \sim m$,
        если $\varphi_n = \varphi_m$.

        Рассмотрим вычислимую функцию $$V(m, x) = \varphi_{f(\varphi_m(m))}(x).$$ По свойству главности
        нумерации $\varphi$ найдётся тотальная вычислимая функция $s$ такая, что $$V(m, x)
        = \varphi_{s(m)}(x).$$ Значит, можем записать, что
        $$
            f(\varphi_m(m)) \sim s(m).
        $$

        Важно отметить, что $s(m)$ тотальна. Какое бы значение $m$ мы не подставили, наше
        утверждение сохранит истинность в силу того, что правая часть уравнения определена.

        Теперь, зная, что $s(m)$ вычислима, запишем её как $\varphi_k(m)$
        $$
            f(\varphi_m(m)) \sim \varphi_k(m),
        $$
        и подставим $m = k$
        $$
            f(\varphi_k(k)) \sim \varphi_k(k).
        $$

        Чудесным образом получили слева и справа вполне определённые значения, так как и $f$,
        и $\varphi_k$ являются тотальными функциями. То есть, неподвижной точкой (в смысле
        определённой нами эквивалентности, а не обычного равенства) функции $f$ является
        $\varphi_k(k)$, совершенно точно определённое значение.
    \end{proof}

    \section{Теорема Райса-Успенского.}

    \begin{theorem}
        Пусть множество $F$ является собственным подмножеством множества частичных вычислимых
        функций (то есть, $F$ не пусто и не совпадает с множеством всех частичных вычислимых
        функций). Тогда множество $\{i \mid \varphi_i \in F\}$ неразрешимо \footnote{Неформально
        эту теорему можно понимать так: по алгоритму вычисления функции нельзя понять
        (алгоритмически), обладает ли она каким-либо свойством. То есть, к примеру, нельзя
        написать алгоритм, решающий, монотонна ли функция, по коду, её вычисляющему.}.
    \end{theorem}

    \begin{proof}
        Обозначим нигде не определённую функцию как $\zeta(x)$. Рассмотрим два случая.

        \begin{itemize}
            \item $\zeta \not\in F, f \in F$

            Пусть $A$ --- перечислимое неразрешимое множество. Хотим m-свести $A$ к $F$. Для этого
            определим функцию $V(n, x)$ следующим образом:
            $$
                V(n, x) =
                \begin{cases}
                    f(x), & \text{$n \in A$,}\\
                    \zeta(x), & \text{иначе.}
                \end{cases}
            $$

            Так как полухарактеристическая функция $A$ вычислима, $V(n, x)$ также вычислима. Кроме
            того, в главной нумерации $\varphi$ найдётся тотальная вычислимая функция $s$ такая, что
            $V(n, x) = \varphi_{s(n)}(x)$. Запишем:
            $$
                \varphi_{s(n)}(x) =
                \begin{cases}
                    f(x), & \text{$n \in A$,}\\
                    \zeta(x), & \text{иначе.}
                \end{cases}
            $$

            Но теперь мы получили, что $n \in A \iff s(n) \in F$. Значит, неразрешимое множество $A$
            m-сводится к нашему множеству $F$. Значит, и $F$ является неразрешимым.

            \item $\zeta \in F, f \not\in F$

            Построив всё аналогично предыдущему пункту, мы получаем, что $n \in A \iff s(n) \not\in F$.
            Это значит, что дополнение $F$ неразрешимо. Само $F$ в таком случае также неразрешимо.
        \end{itemize}
    \end{proof}

\section{Определение машин Тьюринга и вычислимых на машинах Тьюринга функций. Тезис Чёрча-Тьюринга. Неразрешимость проблемы остановки машины Тьюринга.}
Машина Тьюринга задаётся\footnote{Здесь машина Тьюринга определяется в соответсвии с лекцией. Следует понимать, что это определение не является общепринятым. Вариаций масса: кто-то запрещает головке оставаться на месте, кто-то выделяет выходной алфавит, отличный от входного и т. д.}
\begin{itemize}
	\item непустым конечным алфавитом $\Sigma$, среди которого выделен пробельный символ $\vartextvisiblespace$ и не содержащее пробела подмножество $\Gamma$ --- входной алфавит;
	\item непустым конечным множеством состояний $Q$, среди которых выделено начальное состояние $s_0$ и множество терминальных состояний $F$;
	\item функцией переходов $\delta:(Q \setminus F) \times \Sigma \to Q \times \Sigma \times \{-1, 0, +1\}$.
\end{itemize}

Машина Тьюринга состоит из бесконечной ленты, разбитой на ячейки, головки, в любой момент времени указывающей на одну ячейку и одной ячейки памяти, в которой хранится текущее состояние. В начальный момент времени на ленте записано некоторое слово, составленное из букв входного алфавита, головка смотрит на первый символ этого слова, во всех остальных ячейках пробелы. Затем в каждый момент времени вычисляется $\delta(q, c) = (q', c', \Delta)$, где $q$ --- текущее состояние, $c$ --- символ записанный в ячейке, на которую сейчас смотрит головка. Состояние меняется на $q'$, символ в текущей ячейке на $c'$, головка остаётся на месте или передвигается на один влево или вправо в соответствии со значением $\Delta$. Если $q'$ оказалось терминальным, на этом работа машины заканчивается, иначе этот процесс продолжается.

Машины Тьюринга естественным образом отождествляются с частичными функциями $f:\Gamma^* \to \Gamma^*$ --- аргументом функции является входное слово, а возвращает функция слово, записанное на ленте после завершения работы машины(то есть всё, что написано на ленте, кроме бесконечного числа пробелов слева и справа). Функции будут частичными, поскольку машина Тьюринга может продолжать работать бесконечно или в данной конструкции может оказаться, что на выходе есть символ, не содержащийся в $\Gamma$. Функции, которые можно таким образом получить по некоторой машине Тьюринга, называются вычислимыми на машине Тьюринга.
\paragraph{Тезис Чёрча-Тьюринга.} \textit{Любая вычислимая функция вычислима на машине Тьюринга.}

Здесь понятие "вычислимая функция" используется в неформальном смысле, под ним понимается функция, вычислимая в любой разумной модели, которая может прийти вам в голову. Тезис не является формальным утверждением, он никак не доказывается и принимается нами на веру.

\begin{theorem}
	Не существует вычислимой функции, определяющей по машине Тьюринга и входному слову, остановится ли эта машина.
\end{theorem}
Теперь, когда мы отождествили вычислимые и вычислимые на машине Тьюринга функции, эта теорема непосредственно следует из доказательства теоремы о существовании полного перечислимого множества из 7 билета.

\section{Неразрешимость проблемы достижимости в односторонних ассоциативных исчислениях. Полугруппы, заданные порождающими и соотношениями. Теорема Маркова–Поста: неразрешимость проблемы равенства слов в некоторой конечно определенной полугруппе (без доказательства).}

\begin{definition}
	\textit{Односторонним ассоциативным исчислением} называется множество из всех слов над некоторым конечным алфавитом и конечный набор подстановок. Каждая подстановка представляет собой пару слов $(s, t)$ и позволяет в любом слове содержащем $s$ как подстроку заменить её на $t$ (но не наоборот).
\end{definition}

\begin{theorem}
	Существует одностороннее ассоциатвиное исчисление, в котором не разрешима задача проверить по паре слов, можно ли некоторой последовательностью подстановок перейти от первого ко второму.
\end{theorem}

\begin{proof}
	Возьмём некоторую машину Тьюринга $M$, для которой неразрешима проблема остановки, при чём если такую, что если она останавливается, то на ленте записано пустое слово. Построим по ней одностороннее ассоциативное исчисление, в котором из $[X]$ можно получить $Y$, если и только если $M$ преобразует $X$ в $Y$. В качестве алфавита для исчисления возьмём объединение алфавита $M$ и её множества состояний (а также квадратные скобки и символы $\triangleleft, \triangleright$). Будем сопоставлять конфигурациям машины слова исчисления. Если машина находится в состоянии $s$, на ленте записано слово $PQ$(конкатенация слов $P$ и $Q$) и головка указывает на первый символ слова $Q$, сопоставим такой конфигурации слово $[PsQ]$ в нашем исчислении. Тут важно, что мы считаем, что у машины не пересекаются алфавит и множество состояний. Построим по переходам машины подстановки для исчисления.

	\begin{center} \begin{tabular}{c | c }
		Переход МТ & Подстановка одностороннего ассоциативного исчисления \\ \hline
		$(s, c) \mapsto (s', c', 0)$ & $sc \to s'c'$ \\
		$(s, c) \mapsto (s', c', +1)$ & $sc \to c's'$ \\
		$(s, c) \mapsto (s', c', -1)$ & $xsc \to s'xc'$ --- для каждого символа $x$ из алфавита машины, а также $[sc \to [s'\vartextvisiblespace c'$ \\
		$(s, \vartextvisiblespace) \mapsto (s', c', 0)$ & $s] \to s'c']$ \\
		$(s, \vartextvisiblespace) \mapsto (s', c', +1)$ & $s] \to c's']$ \\
		$(s, \vartextvisiblespace) \mapsto (s', c', -1)$ & $xs] \to s'xc']$
	\end{tabular} \end{center}

	Дополнительно к этому введём подстановки, позволяющие получить пустое слово, если машина остановится.
	\begin{itemize}
		\item $f \to \triangleleft$, $f$ --- терминальное состояние;
		\item $c\triangleleft \to \triangleleft, c \ne [$;
		\item $[\triangleleft \to \triangleright$;
		\item $\triangleright c \to \triangleright, c \ne ]$;
		\item $\triangleright ] \to \varepsilon$(пустое слово).
	\end{itemize}

	Это можно было бы реализовать проще без двух дополнительных символов, но так мы получаем, что всегда существует ровно одна последовательностей подстановок, моделирующих работу машины Тьюринга. Осталась одна деталь --- мы пообщеали, что мы начнём с $[X]$, а не с $[s_0X]$. Она решается просто --- добавлением подстановки $[x \to [s_0x$ для всех символом $x$ из алфавита машины.

	Итак, мы свели задачу остановки машины Тьюринга (про которую было известно, что она неразрешима) к задаче достижимости в одностороннем ассоциативном исчислении и показали этим, что эта задача тоже неразрешима.
\end{proof}
Теорема Маркова-Поста гласит, что если потребовать, чтобы все подстановки были двухсторонними, то задача останется неразрешимой, но доказывать этот факт от нас не требуют. При чём такую задачу можно сформулировать на языке алгебры:

Пусть про некоторую полугруппу известно, что она содержит\footnote{Можно потребовать, чтобы в полугруппе были только элементы, порождённые заданными. Это никак не меняет задачу.} элементы $a_1, \ldots, a_n$ и в ней выполняются некоторые (конечное количество) равенства вида $a_{i_1}a_{i_2}\ldots a_{i_k} = a_{j_1}a_{j_2}\ldots a_{j_m}$. Обязательно ли в ней выполняется заданное равенство такого же вида?

\section{Исчисление высказываний (аксиомы и правила вывода), понятие вывода. Теорема корректности исчисления высказываний}
Высказываниями мы называем утверждения, которые либо истинны, либо ложны. При этом если $A, B$ являются высказываниями, то $\lnot A, A \lor B, A \land B, A \to B$ --- тоже высказывания. Из такого определения никак не следует, что высказывания вообще существуют, так что в любом применении исчисления высказываний также описывают некоторые атомарные высказывания. Но нам для доказательства общих фактов это никак не потребуется. Исчисление высказываний задаётся аксиомами и правилами вывода. У нас имеется 11 аксиом:
\begin{enumerate}
	\item $(A \to (B \to C)) \to ((A \to B) \to (A \to C))$
	\item $A \to (B \to A)$
	\item $A \land B \to A$
	\item $A \land B \to B$
	\item $A \to (B \to A \land B)$
	\item $A \to A \lor B$
	\item $B \to A \lor B$
	\item $(A \to C) \to ((B \to C) \to ((A \lor B) \to C))$
	\item $\lnot A \to (A \to B)$
	\item $(A \to B) \to ((A \to \lnot B) \to \lnot A)$
	\item $A \lor \lnot A$
\end{enumerate}
и 1 правило вывода(modus ponens)
\[\tfrac{A \to B, \; A}{B} \]

Вывод в исчислении высказываний --- это последовательность из операций двух видов
\begin{itemize}
	\item Подстановка в некоторую аксиому любых высказываний вместо $A, B, C$.
	\item Применение правила вывода. Если уже выведены $A\to B$ и $A$, можно вывести $B$
\end{itemize}

\begin{theorem}{(Корректность исчисления резолюций)}
	Любая формула, которую можно вывести в исчислении высказываний, истинна(тавтологична).
\end{theorem}
Здесь мы называем формулу истинной(тавтологичной), если она как булева формула верна при всех значениях входящих в неё переменных. Отметим, что только в этом контексте мы понимаем $\lnot, \lor, \land$ как привычные логические операции. С точки зрения исчисления высказываний, это просто какие-то символы, всё что мы про них знаем --- это аксиомы и правило.
\begin{proof}
	Достаточно убедиться, что все действия, который мы можем производить в ходе вывода не позволяют получить ложное выражение. Во-первых, все аксиомы истинны при любых значениях входящих в них переменных. Во-вторых, если $A \to B$ истинно и $A$ истинно, то $B$ истинно.
\end{proof}

\section{Вывод из гипотез. Лемма о дедукции. Полезные производные правила.}
Пусть $\Gamma$ --- некоторое множество высказываний(гипотез). Тогда говорят, что формула $A$ выводится из $\Gamma$, если её можно вывести,  разрешая пользоваться не только аксиомами и правилом вывода, но и высказываниями из $\Gamma$. Можно сказать, что у нас появилась третья операция: бесплатно получить формулу из $\Gamma$. Обозначение: $\Gamma \vdash A$. В таких терминах можно сказать, что формула, которую можно вывести в исчислении высказываний,  выводится из пустого множества гипотез, обозначение: $\ \vdash A$.

\begin{lemma}
	$\ \vdash A \to A$
\end{lemma}

\begin{proof}
	\begin{enumerate}
		\item $A \to (A \to A)$(2 аксиома)
		\item $\lnot A \to (A \to A)$ (9 аксиома)
		\item $A \lor \lnot A$ (11 аксиома)
		\item $(A \to (A \to A)) \to ((\lnot A \to (A \to A)) \to ((A \lor \lnot A) \to (A \to A)))$ (8 аксиома, подставлены $A, \lnot A, A \to A$)
		\item $(\lnot A \to (A \to A)) \to (A \lor \lnot A) \to (A \to A)$ (modus ponens)
		\item $(A \lor \lnot A) \to (A \to A)$ (modus ponens)
		\item $A \to A$ (modus ponens)
	\end{enumerate}
\end{proof}

\begin{theorem}{(Лемма о дедукции)}
	$\Gamma \cup \{A\} \vdash B \implies \Gamma \vdash (A \to B)$
\end{theorem}

\begin{proof}
	Пусть с набором гипотез $\Gamma \cup \{A\}$ мы могли вывести формулу $B$, последовательно выводя формулы $B_1, B_2, \ldots, B_n, B_n = B$. По индукции докажем, что с набором гипотез $\Gamma$ можно доказать последовательность $A \to B_1, \ldots, A \to B_n$. Разберём для этого все способы, которыми мы умеем выводить
	\begin{enumerate}
	\item $B_i$ получено как гипотеза. Если $B_i = A$, то по лемме мы сможем вывести $A \to A$. Иначе нам доступен такой вывод: $B_i, B_i \to (A \to B_i), A \to B_i$.
	\item $B_i$ получено подставлением формул в аксиому. Работает последовательность из предыдущего пункта.
	\item $B_i$ получено по modus ponens из $B_j$ и $B_k(j < i , k < i)$. Тогда без потери общности считаем, что $B_j = B_k \to B_i$. По предположению индукции мы уже вывели $A \to B_k$ и $A \to (B_k \to B_i)$. По первой аксиоме выведем $A \to (B_k \to B_i) \to ((A \to B_k) \to (A \to B_i))$. Дважды применив к этому modus ponens, получим $A \to B_i$.
	\end{enumerate}
\end{proof}
Некоторые производные правила --- следствия из леммы о дедукции:
\begin{itemize}
	\item Из $A$ и $B$ можно вывести $A \land B$.
	\item Если из $\Gamma \cup \{A\}$ можно вывести $B$ и $\lnot B$, то из $\Gamma$ можно вывести $\lnot A$ (производное правило доказательства от противного).
	\item Если из $\Gamma \cup \{A\}$ можно вывести $B$ и из $\Gamma \cup \{\lnot A\}$ можно вывести $B$, то из $\Gamma$ можно вывести $B$ (производное правило разбора случаев).
	\item Из $A, \lnot A$ можно вывести что угодно.
\end{itemize}

\section{Теорема полноты исчисления высказываний.}
\begin{lemma}
	Пусть формула $A$ зависит от переменных $p_1, \ldots, p_n$. При этом при $(p_1, \ldots, p_n) = (\varepsilon_1, \ldots, \varepsilon_n)$ формула выдаёт значение $\varepsilon$. Тогда $\{p_1^{\varepsilon_1}, \ldots, p_n^{\varepsilon_n}\} \vdash A^{\varepsilon}$, где
\[P^\varepsilon = \begin{dcases*} \lnot P, & $\varepsilon = 0$ \\ P& $\varepsilon = 1$ \end{dcases*} \]
\end{lemma}

\begin{proof}
	Доказательство индукцией по построению формулы $A$. Разбираем все способы, которыми она была построена, а для них все значения её составных частей.
	\begin{enumerate}
		\item $A = p$. Очевидно, $p \vdash p$ и $\lnot p \vdash \lnot p$.
		\item $A = B \land C$.
		\begin{enumerate}
			\item Пусть $B$ и $C$ истинны. Тогда по предположению индукции мы можем вывести $B$ и $C$ и требуется показать, что мы можем вывести $B \land C$. Мы умеем это делать по производному правилу.
			\item Пусть $B$ истинно, а $C$ ложно. Тогда по предположению индукции мы можем вывести $B$ и $\lnot C$, и хотим вывести $\lnot(B \land C)$. Воспользуемся правилом доказательства от противного и добавим себе в гипотезы $B \land C$. Из $B \land C$ нетрудно вывести $C$, и мы умеем выводить $\not C$, противоречие достигнуто.
		\end{enumerate}
		Оставшиеся два случая аналогичны второму.
		\item $A = B \lor C$. Если хотя бы одно из $B$ или $C$ истинно, то ясно, что можно вывести $B \lor C$. Пусть теперь мы умеем выводить $\lnot B, \lnot C$ и нужно вывести $\lnot (B \lor C)$. Снова будем выводить от противного и предположим $B \lor C$. Заметим, что из $\lnot B, \lnot C, B$ можно вывести всё что угодно, и из $\lnot B, \lnot C, C$ можно вывести всё что угодно. Тогда всё что угодно можно вывести и из $\lnot B, \lnot C, B \lor C$, в том числе и противоречие.
		\item $A = B \to C$. Для случаев с истинным $B$ или ложным $C$ вывод простой --- достаточно воспользоваться 2 или 9 аксиомой (и modus ponens). Пусть мы умеем выводить $B, \lnot C$ и нужно вывести $\lnot(B \to C)$. Опять докажем от противного и по modus ponens из $B, B \to C$ выведем $C$. Это даст противоречие, поскольку у нас есть $\lnot C$.
		\item $A = \lnot B$. Ясно, что $\lnot B \vdash \lnot B$. Нужно доказать, что $B \vdash \lnot \lnot B$. Для этого нужно в очередной раз доказать от противного и вывести из $B, \lnot B$ какое-нибудь противоречие. Но $B, \lnot B$ уже противоречие.
	\end{enumerate}
\end{proof}

\begin{theorem}{(Полнота исчисления высказываний)}
	Любую тавтологию можно вывести в исчислении высказываний.
\end{theorem}

\begin{proof}
	Пусть тавтология $A$ зависит от переменных $p_1, \ldots, p_n$. Тогда по лемме $p_1, \ldots, p_n \vdash A$. И $p_1, \ldots, \lnot p_n \vdash A$. И вообще как угодно можно расставить отрицания, потому что $A$ --- тавтология. Из двух приведённых фактов по производному правилу $p_1, \ldots, p_{n - 1}, p_n \lor \lnot p_n \vdash A$. Но $p_n \lor \lnot p_n$ можно получить из аксиомы, значит это можно выкинуть из списка гипотез и получить $p_1, \ldots, p_{n - 1} \vdash A$. Аналогично начав с $p_1, \ldots, \lnot p_{n - 1}, p_n \vdash A$ и $p_1, \ldots, \lnot p_{n - 1}, \lnot p_n \vdash A$, мы получим $p_1, \ldots, \lnot p_{n - 1} \vdash A$. Из этих двух результатов мы сможем избавиться от $p_{n - 1}$ и получить $p_1, \ldots, p_{n - 2} \vdash A$. Долго повторяя этот процесс, мы избавимся от всех переменных и получим $\ \vdash A$, а это то, что требовалось.
\end{proof}

\section{Исчисление резолюций для опровержения пропозициональных формул в конъюнктивной нормальной форме (КНФ): дизъюнкты, правило резолюции, опровержение КНФ в исчислении резолюций. Теорема корректности исчисления резолюций (для пропозициональных формул в КНФ)}
Если исчисление высказываний работало с произвольными формулами, построенными с помощью отрицания, конъюнкции, дизъюнкции и импликации, исчисление резолюций работает только с дизъюнктами.

\begin{definition} \textit{Литерал} --- переменная или отрицание переменной \end{definition}
\begin{definition} \textit{Дизъюнкт} --- это дизъюнкция по некоторому конечному множеству литералов \end{definition}

Обратите внимание, что в этом определении речь про множество. Хотя мы записываем дизъюнкты как формулы $\lambda_1 \lor \lambda_2 \lor \ldots \lor \lambda_n$, мы считаем, что, к примеру, $\lambda_1 \lor \lambda_2, \lambda_2 \lor \lambda_1, \lambda_1 \lor \lambda_2 \lor \lambda_1$ --- это всё один и тот же дизъюнкт.

У исчисления резолюций нет аксиом и есть одно правило --- правило резолюции
\[\tfrac{A \lor p, \; B \lor \lnot p}{A \lor B} \]
Отметим, что при применении правила к $p$ и $\lnot p$ результатом будет пустой дизъюнкт, который обозначается как $\perp$(или как $\square$).

На записанные в КНФ пропозиональные формулы можно смотреть как на множества дизъюнктов в исчислении резолюций. Будем говорить, что множество дизъюнктов совместно, если есть набор значений переменных, при котором каждый дизъюнкт возвращает истину. Утверждается, что из множества дизъюнктов можно вывести в исчислени пустой дизъюнкт, если и только если множество несовместно.

\begin{theorem}{(Корректность исчисления резолюций)}
	Если множества дизъюнктов можно вывести пустой дизъюнкт, то оно несовместно.
\end{theorem}
\begin{proof}
	Можно убедиться, что из истинных (при каких-то значениях переменных) формул можно вывести только истинные (при тех же значениях). Но пустой дизъюнкт всегда ложен.

	Если вам по каким-либо причинам не нравятся слова о ложности пустого дизъюнкта, можно сказать, что пустой дизъюнкт можно вывести только из $p, \lnot p$, а они не могут быть истинны одновременно.
\end{proof}

\section{Теорема полноты исчисления резолюций (для пропозициональных формул в КНФ). Доказательство только для конечных и счетных множеств формул.}
\begin{theorem}{(Полнота исчисления резолюций)}
	Если множество дизъюнктов $S$ несовместно, то из него можно вывести пустой дизъюнкт.
\end{theorem}
Докажем для случая, когда $S$ не более чем счётно.
\begin{proof}
	Применим контрапозицию и докажем, что если из $S$ нельзя вывести пустой дизъюнкт, то оно совместно. Обозначим за $S'$ множество всех формул, которые можно вывести из $S$. Поскольку множество дизъюнктов не более чем счётно, а сами дизъюнкты конечны, множество используемых переменных тоже будет не более чем счётно. Занумеруем их $x_1, x_2, \ldots$. Докажем, что можно так выбрать значения переменным, что для любого $n$ все дизъюнкты из $S'$, содержащие только переменные с номерами не больше $n$, истинны. Ясно, что это и означает совместность. Доказывать будем индукцией по $n$.
	\paragraph{База индукции.} Это могло бы быть неверно для $n = 1$, только если бы в $S'$ содержались $x_1$ и $\lnot x_1$. Но такого быть не может, ведь тогда мы могли бы вывести пустой дизъюнкт.
	\paragraph{Шаг индукции.} По предположению индукции мы уже как-то умеем выбирать значения для переменных $x_1, \ldots, x_n$. Предположим, выбрать значение для $x_{n + 1}$ нельзя.
	\begin{itemize}
	\item $x_{n + 1} = 0$ не подходит $\implies A \lor x_{n + 1} \in S'$, где $A$ содержит только $x_1,\ldots, x_n$ и ложно при выбранных для них значениях.
	\item $x_{n + 1} = 1$ не подходит $\implies B \lor \lnot x_{n + 1} \in S'$, где $B$ содержит только $x_1,\ldots, x_n$ и ложно при выбранных для них значениях.
	\end{itemize}
	Но тогда можно вывести $A \lor B$. Поскольку $A \lor B$ содержит только $x_1, \ldots, x_n$, по предположению индукции оно верно при выбранных значениях. А значит не может быть, что и $A$, и $B$ ложны, противоречие.
\end{proof}
На самом деле аналогичным образом можно было бы доказать корректность и для несчётных множеств формул (для корректности индукции пришлось бы прибегнуть к теореме Цермело), но несчётное число переменных --- это крайне нетипичная ситуация и этим мы тут не занимаемся.

\section{Полиномиальный алгоритм сведения задачи распознавания совместности конечных множеств произвольных формул к задаче распознавания совместности конечных множеств дизъюнктов.}
Перейти от формулы к конечному множеству дизъюнктов --- то же самое, что привести её к КНФ. Ясно, что формулу длины $l$, зависящую от $m$ переменных, можно за $O(2^m \cdot l)$ --- построить таблицу истинности и взять дизъюнкты, соответствующие строкам, в которых формула ложна, но этот метод не полиномиальный.

Пусть наша формула имеет вид $f(A, B)$ --- где $A, B$ --- некоторые формулы, а $f$ --- операция, выполняющаяся в нашей формуле последней. Тогда введём новые переменные $x', x''$ и заменим нашу формулу на $f(x', x'') \land (x' \equiv A) \land (x'' \equiv B)$. Длина формулы $f(x', x'')$ ---константа, следовательно экспоненциальный метод сведёт её к КНФ за $O(1)$. Теперь нам нужно как-то разобраться с $(x' \equiv A)$ и $(x'' \equiv B)$. Снова посмотрим на последнюю операцию в $A$, заменим её аргументы на новые переменные. После этого скобка $(x' \equiv A)$ будет содержать только три переменные --- $x'$ и две новейшие, её снова можно обработать наивным алгоритмом. При этом у нас появятся новые скобки с эквивалентностями, будем повторять то же самое для них, пока не упрёмся в операции над переменными, а не над результатами формул. За каждый запуск наивного алгоритма мы избавляемся от одной операции в исходной формуле, поэтому время работы можно оценить как $O(l)$.

Мы дали описание для бинарных операций, но ясно, что тот же самый подход замены выражений на переменные применим и для отрицания, и для каких-то экзотических операций.

\section{Определение формулы первого порядка в данной сигнатуре. Свободные и связанные вхождения переменных. Интерпретации данной сигнатуры. Общезначимые и выполнимые формулы. Равносильные формулы.}
\begin{definition} \textit{Сигнатура} языка --- набор функциональных и предикатных символов определённых валентностей. \end{definition}
Формулы первого порядка состоят из кванторов, индвидных переменных, функциональных и предикатных символов. Но для того, чтобы дать корректное определение формуле первого порядка, нам потребуется ввести ещё несколько вспомогательных понятий. Во-первых, \textit{терм}.
\begin{enumerate}
	\item Любая индвидная переменная является термом.
	\item Если $f$ --- функциональный символ валентности $n$, а $t_1, \ldots, t_n$ --- термы, то $f(t_1, \ldots, t_n)$ --- терм.
\end{enumerate}
 Во-вторых, будем называть \textit{атомарной формулой} выражение вида $P(t_1, \ldots, t_n)$, где $P$ --- предикатный символ валентности $n$, а $t_1, \ldots, t_n$ --- термы. Теперь мы готовы дать определение формуле первого порядка (далее --- просто формуле).
\begin{definition}
	\begin{enumerate}
		\item Атомарные формулы являются формулами.
		\item Если $a, b$ --- формулы, то $(a \land b), (a \lor b), (a \to b), \lnot a$ также являются формулами.
		\item Если $a$ --- формула, то $(\exists x \  a)$ и $(\forall x \  a)$ также являются формулами.
	\end{enumerate}
\end{definition}
Скобки в определении нужны для того, чтобы можно было однозначно определять приоритет операций. Для удобства мы (как и любой разумный человек) не будем ставить все из этих скобок.

Если перед каждым появлением переменной в формуле в составе терма эта переменная появляется под квантором, говорят что она \textit{связана} в этой формуле. Иначе говорят, что она входит в формулу \textit{свободно}. Формула без свободных вхождений переменных называется \textit{замкнутой}.
\begin{definition}
	\textit{Интерпретация} данной сигнатуры состоит из непустого множества $M$ (\textit{носителя}) и функций, сопоставленных каждому символу. Функциональному символу $f$ валентности $n$ сопоставляется функция $\hat{f}:M^n \to M$, а предикатному символу $p$ валентности $m$ --- функция $\hat{p}:M^m \to \{0, 1\}$.

Ясно, что после выбора интерпретации любой замкнутой формуле данной сигнатуры можно одннозначно сопоставить значение. При этом формула называется \textit{общезначимой}, если она верна в любой интерпретации и \textit{выполнимой}, если верна хотя бы в какой-то. Обычно эти термины применяют только к замкнутым формулам, но если формула содержит свободные переменные, то считается, что она верна, если она верна при любых их значениях. Формулы $A$ и $B$ называются равносильными, если формула $(A \to B) \land (B \to A)$ общезначима.
\end{definition}

\section{Теории и их модели. Семантическое следование. Теорема Черча об алгоритмической неразрешимости отношения семантического следования и общезначимости формул (в доказательстве теоремы можно использовать существование конечно определенной полугруппы с неразрешимой проблемой равенства).}
\begin{definition} \textit{Теория} --- некоторое множество замкнутых формул \end{definition}
\begin{definition}
	Интерпретация $M$ соответствующей сигнатуры, в которой верны все формулы теории $T$, называется \textit{моделью} $T$. Обозначение: $M \vDash T$.
\end{definition}
\begin{definition}
	Формула $A$ называется \textit{семантическим следствием} теории $T$, если в любой модели $T$ истинна $A$. Обозначение: $T \vDash A$
\end{definition}
\begin{theorem}{(Чёрч)}
	Множество общезначимых формул неразрешимо
\end{theorem}
\begin{proof}
	Будем говорить, что теория $T$ разрешима, если множество формул $\{A | T \vDash A\}$ разрешимо. Тогда если найдётся неразрешимая теория с конечным числом формул, теорема будет доказана. Действительно, пусть $T = \{A_1, \ldots, A_n\}$. Тогда проверить, следует ли из неё формула $A$ --- то же самое, что проверить, общезначима ли формула $(A_1 \land \ldots \land A_n) \to A$. Значит если мы не умеем проверять на следование из теории, то не умеем и проверять на общезначимость.

	Построим неразрешимую теорию, пользуясь теоремой Маркова-Поста. Выберем некоторую полугруппу, порождённую $a_1, \ldots, a_n$ с неразрешимой проблемой равенства. В качестве сигнатуры возьмём функциональные символы $\cdot, =$ валентности 2 и $a_1, \ldots, a_n$ валентности 0. В качестве аксиом возьмём аксиому полугруппы $\forall x \forall y \forall z \  x \cdot (y \cdot z) = (x \cdot y) \cdot z$ и все имеющиеся у нас равенства. Теперь проблема равенства превращается в проверку на семантическое следование из этой теории, значит оно тоже неразрешимо.
\end{proof}

\section{Дизъюнкты, универсальные дизъюнкты. Исчисление резолюций (ИР) для доказательства несовместности множеств универсальных дизъюнктов. Теорема корректности ИР.}
\begin{definition}
	\textit{Дизъюнктом} называется дизъюнкция атомарных формул и их отрицаний.\\
	Пример: $P(x) \vee \overline Q(y, f(x)) \vee s$ (в данном случае $P(x), \overline Q(y, f(x)), s$ --- атомарные формулы, а $\vee$ --- операция дизъюнкции)
\end{definition}
\begin{definition}
	\textit{Универсальным дизъюнктом} называется формула, полученная из дизъюнкта приписыванием кванторов всеобщности. Пример: $\forall x\forall y [P(x) \vee \overline Q(y, f(x)) \vee s]$
\end{definition}
Для того, чтобы доказывать несовместность множеств универсальных дизъюнктов (несовместность конъюнкции всех универсальных дизъюнктов этого множества) мы пользуемся правилами в исчислении резолюций
\vspace{2mm}

Правил в исчислении резолюций два:
\begin{itemize}
	\item $\tfrac{A \vee p,\ B \vee \overline p}{A \vee B}$ (правило резолюций)
	\item $\forall x D(x) \vDash D(t)$ для некоторого $t$
\end{itemize}

\begin{theorem}{(Теорема корректности исчисления резолюций)}
	Если из набора универсальных дизъюнктов можно вывести пустой дизъюнкт, то этот набор несовместен.
\end{theorem}
\begin{proof}
	Идем методом от противного. Пускай существует модель $M$, в которой все данные дизъюнкы истинны.
	Заметим, что оба правила исчисления резолюций сохраняют истинность.

	Действительно, если в правиле резолюций для $\tfrac{A \vee p,\ B \vee \overline p}{A \vee B}$ мы получим, что $A \vee B$ ложно, то это значит, что и $A$, и $B$ ложно, однако если это так, то ложно либо $A \vee p$, либо $B \vee \overline p$

	В правиле резолюций для $\forall x D(x) \vDash D(t)$, если выражение $D(x)$ истинно для любого
    $x$, то оно будет истинно для и для некоторого $t$ \footnote{В случае $\forall x \exists y, x < y$ не выполняется, если мы поставим $x = y$. Однако наши универсальные дизъюнкты не допускают квантора существования, поэтому такая формула невозможна}

	Если мы вывели пустой дизъюнкт, то по истинности правил исчисления резолюций получаем, что пустой дизъюнкт является истинным. Противоречие.
\end{proof}

\section{Непротиворечивые теории. Теорема полноты ИР (для множеств универсальных дизъюнктов).}
\begin{definition}
	\textit{Непротиворечивой теорией} называется теория такая, что в ней утверждение не может быть одновременно доказано и опровергнуто
\end{definition}

\begin{theorem}{(Теорема полноты исчисления резолюций)}
	Если набор универсальных дизъюнктов несовместен, то из него можно вывести пустой дизъюнкт
\end{theorem}
\begin{proof}
	Пускай есть счётное множество универсальных дизъюнктов $S$. Построим множество $S'$ следующим образом: добавим к $S$ все возможножные подстановки термов вместо переменных под кванторами. Множество так и останется не более чем счётным. Заметим, что мы можем смотреть на атомарные формулы как на пропозициональные переменные (можем подобрать интерпретацию, в которой для данного набора значений пропозициональных переменных соотвествующие атомарные формулы на некотором наборе термов давали такое же значение)
	
	\begin{lemma}{(Теорема Эрбрана)}
	    Если множество $S'$ совместно, то можно составить модель для $S$.
	\end{lemma}
	
	\begin{proof}
	     Для этого, пускай получена соответствующая интерпретация для $S'$. Возвращаемся к атомарным формулам: мы знаем конкретные значения переменных, поэтому построим некоторые функции и предикаты так, чтобы они выдавали соответствующие значения для выбранной интерпретации $S'$. Теперь вернём кванторы: так как в нашем множестве истинны все подстановки термов в формуле, то и квантор всеобщности для неё будет истинным. Таким образом, мы вернулись к $S$, построив интерпретацию для неё
	\end{proof}
	
	Контрапозицией леммы мы получаем, что раз $S$ несовместно, то $S'$ тоже несовместно. Однако $S'$ будет множеством дизъюнктов пропозициональных переменных, для которого мы можем применить теорему о полноте ИР из 16 билета и вывести пустой дизъюнкт. А так как $S'$ --- это $S$, расширенное применением второго правила ко всем значениям переменных под кванторами, то из $S$ пустой дизъюнкт тоже выводим
	
\end{proof}

\section{Исчисление резолюций для теорий, состоящих из формул общего вида (приведение к предваренной нормальной форме и сколемизация). Доказательства общезначимости с помощью ИР. Выводимость формулы в теории с помощью ИР. Теорема компактности.}
Для того, чтобы применить правила исчислений резолюций для теорий, состоящих из формул общего вида необходимо для начала привести их к форме, состоящей из конъюнкций, дизъюнкций, отрицаний атомарных формул и кванторов всеобщности. Поэтому каждую формулу приводят сначала к \textit{предваренной нормальной форме}, а затем к \textit{сколемовской нормальной форме}

\begin{definition}
	\textit{Нормальной формой} называется формула, состоящая только из конъюнкций, дизъюнкций, отрицаний атомарных формул и кванторов
\end{definition}

\begin{definition}
	\textit{Предваренной нормальной формой} называется нормальная форма формулы, кванторы которой стоят в начале
\end{definition}

\begin{definition}
	\textit{Сколемовской нормальной формой} называется предваренная нормальная форма формулы, кванторы которой являются кванторами всеобщности
\end{definition}

Для приведения к нормальной форме нужно преобразовывать нестандартные операции в вид конъюнкций, дизъюнкций и отрицаний (Пример: $A \rightarrow B \equiv \overline{A} \vee B$), а также пользоваться следующими правилами:
\begin{itemize}
	\item $\overline{\exists x A(x)} \equiv \forall x\overline{A(x)}$
	\item $\overline{A \vee B} \equiv \overline{A} \wedge \overline{B}$
\end{itemize}

Для приведения к предваренной нормальной форме нужно вынести кванторы. Делается это при помощи следующих правил:
\begin{itemize}
	\item $C \vee \forall x A(x) \equiv \forall x[C \vee A(x)]$, $C$ не зависит от $x$, операции между A(x) и C могут быть любые ($\vee$ или $\wedge$), квантор для $x$ тоже любой ($\forall$ или $\exists$)
	\item $\forall x A(x) \vee \forall x B(x) \equiv \forall x\forall y[A(x) \vee B(y)]$, тоже для любых операций и кванторов
	\item $\forall x A(x) \vee \forall x B(x) \vdash \forall x[A(x) \vee B(x)]$, для любых операций
	\item $\exists x[A(x) \vee B(x)] \vdash \exists x A(x) \vee \exists B(x)$, для любых операций
\end{itemize}

Для приведения к сколемовской нормальной форме будем использовать следующую операцию:
\begin{itemize}
	\item Убираем самый левый квантор существования. Заменяем его в атомарных формулах на функцию от всех предыдущих кванторов всеобщности.

	Пример: $\forall x \exists y \forall z \exists w[A(x, w) \vee B(y, z)] \vdash \forall x \forall z \exists w[A(x, w) \vee B(f_y(x), z)] \vdash \forall x \forall z[A(x, f_w(x, z)) \vee B(f_y(x), z)]$

	Функции $f_y, f_w$ называются \textit{сколемовскими функциями}
\end{itemize}

\textit{Общезначимость формулы} можно доказывать с помощью исчисления резолюций. Для этого возьмём отрицание этой формулы. Общезначимасть формулы $\Leftrightarrow$ несовместности отрицания. А несовместность доказываем с помощью исчисления резолюций, выводя пустой дизъюнкт.

\textit{Выводимость формулы в теории} можно доказывать с помощью исчисления резолюций. Для этого (пусть формулы --- $A$ и $B$) заметим, что выводимость равносильна несовместности формулы $A \wedge \overline{B}$ (если есть хоть один набор терм, что эта формула истинна, то для него, слеедовательно, из $A$ не выводима формула, истинная при всех значениях, при которых истинна $B$)

Пусть $T$ --- множество формул (может быть как конечным, так и счётным)
\begin{theorem}{(Теорема компактности)}
	Если $T$ несовместно, то у него существует несовместное конечное подмножество $T'$
\end{theorem}

\begin{proof}
    Для конечного множества очевидно (берём в качестве подмножества само множество)

	Для счётного множества: так как $T$ несовместно, то из него можно вывести пустой дизъюнкт (теорема полноты ИР, билет 21). Причём этот пустой дизъюнкт выводится из конечного числа исходных формул (так как сами формулы конечные и число операций конечно). Поэтому возьмём в качестве $T'$ эти формулы. Из них выводится пустой дизъюнкт (теорема корректности ИР, билет 20), а значит $T'$ несовместна
\end{proof}

\section{Гомоморфизмы, эпиморфизмы (сюръективные гомоморфизмы), изоморфизмы. Теорема о сохранении истинности при эпиморфизме. Изоморфные модели. Элементарно эквивалентные модели, элементарная эквивалентность изоморфных моделей.}
$\Gamma$ --- сигнатура

$M_1, M_2$ --- интерпретации $\Gamma$
\begin{definition}
	\textit{Гомоморфизмом $h: M_1 \rightarrow M_2$} называется отображение, сохраняющее все предикаты и формулы в сигнатуре.

	Для предиката $P^n \in \Gamma$, его интерпретаций $P_1 \in M_1, P_2 \in M_2$ действует \\
	$\forall a_1, a_2,..., a_n[P_1(a_1, a_2,..., a_n) = P_2(h(a_1), h(a_2),..., h(a_n))]$

	Для формулы $f^n \in \Gamma$, его интерпретаций $f_1 \in M_1, f_2 \in M_2$ действует \\
	$\forall a_1, a_2,..., a_n[h(f_1(a_1, a_2,..., a_n)) = f_2(h(a_1), h(a_2),..., h(a_n))]$
\end{definition}

\begin{definition}
	\textit{Эпиморфизмом (сюръективным гомоморфизмом) $h: M_1 \rightarrow M_2$} называется, если $h$ - гомоморфизм и является сюръекцией
\end{definition}

\begin{definition}
	\textit{Изоморфизмом $h: M_1 \rightarrow M_2$} называется, если $h$ - гомоморфизм и является биекцией
\end{definition}

\begin{definition}
	\textit{$M_1$ элементарно эквивалентно $M_2$ ($M_1 \cong M_2$)}, если для любой замкнутой формулы $A$ сигнатуры $\Gamma$ $M_1 \vDash A \Leftrightarrow M_2 \vDash A$ (формула истинна в $M_1$ т. и т.т, когда она истинна в $M_2$)
\end{definition}

Пусть $h: M_1 \rightarrow M_2$ --- эпиморфизм

$A(x_1,..., x_n)$ --- произвольная формула
\begin{theorem}{(Теорема о сохранении истинности при эпиморфизме)}
	Для всех элементов $a_1,..., a_n \in M_1, M_1 \vDash A(a_1,..., a_n) \leftrightarrow M_2 \vDash A(h(a_1),..., h(a_2))$
\end{theorem}

\begin{proof}
    \begin{lemma}
        для терма $t$ верно, что $h(|t(a_1,..., a_n)|_1) = |t(h(a_1),..., h(a_n))|_2$ ($|t(...)|_1$ - терм в интерпретации $M_1$)
    \end{lemma}

    \begin{proof}
        Пусть $t = f(x, g(y))$. Тогда $|t(a,b)|_1 = f_1(a, g_1(b))$

        $h(f_1(a, g_1(b)) = f_2(h(a), h(g_1(b))) = f_2(h(a), g_2(h(b)))$, мы пользуемся тем, что при гомоморфизме функции и предикаты сохраняются
    \end{proof}

    Пользуемся идукцией по построению $A$
    \begin{enumerate}
        \item База индукции: $A = P(t_1,..., t_m)$

        $M_1 \vDash A(a_1,...,a_m) \leftrightarrow P_1(|t_1(a_1,..., a_m)|_1,...) = 1 \Leftrightarrow P_2(h(t_1(a_1,..., a_m)),...) = 1$\\
        $\Leftrightarrow P_2(|t_1(h(a_1),..., h(a_m))|_2)$ (по лемме) $\leftrightarrow M_2 \vDash A(h(a_1),..., h(a_m))$

        \item Индуктивный переход: разбиваем на случаи:
        \begin{itemize}
            \item $A = B \vee C$

            $M_1 \vDash (B(a,...) \vee C(a,...)) \Leftrightarrow M_1 \vDash B$ или $M_1 \vDash C \Leftrightarrow M_2 \vDash B(h(a),...)$ или $M_2 \vDash C(h(a),...) \Leftrightarrow M_2 \vDash (B \vee C)(h(a),...)$ (аналогично доказывается для остальных операций)
            \item $A = \exists x B(x, y)$

            $M_1 \vDash \exists x B(x, a) \leftrightarrow \exists b \in M_1, M_1 \vDash B(b, a) \leftrightarrow \exists b \in M_1, M_2 \vDash B(h(b), h(a)) \leftrightarrow \exists c \in M_2, M_2 \vDash B(c, h(a)) \leftrightarrow M_2 \vDash \exists x B(x, h(a))$ (предпоследняя эквивалентность верна именно потому, что у нас эпиморфизм), квантор всеобщности доказывается аналогично
        \end{itemize}
    \end{enumerate}
\end{proof}

\begin{theorem}{(Элементарная эквивалентность изоморфных моделей)}
	Если модели $M_1$ и $M_2$ изоморфны, то они элементарно эквивалентны \footnote{Для элементарной эквивалентности достаточно даже просто эпиморфизма, но мы используем более частую формулировку теоремы}
\end{theorem}

\begin{proof}
    Рассматриваем только замкнутые формулы $A$. Из предыдущей теоремы следует, что формула $A$ сохраняет свою истинность при изоморфизме, а это значит, что $M_1$ и $M_2$ будут элементарно эквивалентны по определению.
\end{proof}

\setcounter{section}{23}

\section{Выразимые (определимые) в данной модели отношения. Теорема о сохранении автоморфизмами выразимых предикатов. Доказательства невыразимости с помощью автоморфизмов.}

Далее из учебника.

Пусть фиксирована некоторая сигнатура $\sigma$ и её интерпретация с носителем $M$. Мы хотим определить понятие выразимого (с помощью формулы данной сигнатуры в данной интерпретации) $k$-местного предиката.
Выберем $k$ переменных $x_1, \dots, x_k$ и рассмотрим произвольную формулу $\phi$, все параметры которой содержатся в списке $x_1, \dots, x_k$. Истинность этой формулы зависит только от значений переменных $x_1, \dots, x_k$. Тем самым возникает отображение $M^k \rightarrow \{1, 0\}$, то есть некоторый $k$-местный предикат на $M$.

Говорят, что этот предикат выражается формулой $phi$. Все предикаты, которые можно получить таким способом, называются \textit{выразимыми}. (Ясно, что конкретный выбор списка переменных роли не играет.) Соответствующие им подмножества множества $M^k$ (области истинности выразимых предикатов) также называют \textit{выразимыми}.


\begin{theorem}
	Любой предикат, выразимый в данной интерпретации, устойчив относительно её автоморфизмов.
\end{theorem}

\begin{proof}
	Доказательство приведено в \href{https://www.mccme.ru/free-books/shen/shen-logic-part2-2.pdf}{учебнике} на странице 87.
\end{proof}

Теперь понятно, как доказывать невыразимость предиката в данной модели \textemdash\ нужно построить автоморфизм модели, не сохраняющий предикат (если бы предикат был выразим, любой автоморфизм его бы сохранил).

\setcounter{section}{24}
\section{Нормальные модели. Аксиомы равенства. Теорема о существовании нормальных моделей у непротиворечивых теорий, содержащих аксиомы равенства.}

\begin{definition}
	Нормальные модели \textemdash\ модели, в которых отношение равенства трактуется как совпадение элементов носителя.
\end{definition}

\begin{definition}
	Аксиомы равенства \textemdash\ 3 аксиомы эквивалентности и аксиомы сохранения значений предикатных и функциональных символов
\end{definition}
\begin{itemize}
	\item $\forall x\ x = x$
	\item $\forall x \forall y\ (x = y \rightarrow y = x)$
	\item $\forall x \forall y \forall z ((x = y \wedge y = z) \rightarrow x = z)$
	\item $\forall x \forall y \forall x' \forall y' ((x = x' \wedge y = y') \rightarrow (P(x, y) \iff P(x', y')))$ \textemdash\ так для всех предикатных символов $P$ из сигнатуры (валентность 2 для примера)
	\item $\forall x \forall y \forall x' \forall y' ((x = x' \wedge y = y') \rightarrow (f(x, y) = f(x', y')))$ \textemdash\ аналогично для всех функциональных символов $f$
\end{itemize}

Хотим научиться проверять, есть ли у системы аксиом нормальные модели. Чтобы доказать, что нормальных моделей нет, нужно добавить к системе аксиомы равенства и попробовать вывести пустой дизъюнкт в ИР.

\begin{theorem}
	Если $T$ \textemdash\ произвольное множество замкнутых формул, в сигнатуру входит знак равенства, тогда $T$ не имеет нормальных моделей $\iff$ из $T' = T \cup \{\text{аксиомы равенства}\} \vdash $ пустой дизъюнкт в ИР.
\end{theorem}

\begin{proof}
	В одну сторону (справа налево): пусть получилось вывести пустой дизъюнкт. Тогда по теореме полноты $T'$ не имеет модели, и $T$ не может иметь нормальных моделей (так как в них выполнены аксиомы равенства).

	Слева направо: нужно доказать, что если добавить аксиомы равенства в $T$, выводится пустой дизъюнкт. Докажем вместо этого, что если из $T'$ не выводится пустой дизъюнкт, то $T$ имеет нормальную модель.

	Если из $T'$ не выводится пустой дизъюнкт, у неё есть какая-то модель $M$ (не обязательно нормальная). Аксиомы равенства говорят, что равенство в этой модели должно интерпретироваться как отношение эквивалентности (первые 3 аксиомы) и должно сохранять функциональные и предикатные символы. Проведем параллель с алгеброй и "факторизуем" модель по этому отношению эквивалентности (то есть сопоставим элементу $x$ его класс эквивалентности $[x]$), получим $\faktor{M}{\sim}$ и далее будем работать с классами эквивалентности. Равенство на новом множестве определим как совпадение элементов, а функциональные и предикатные символы таким образом: $P([x_1], \dots, [x_n]) = \left[P(x_1, \dots, x_n)\right]$, $f([x_1], \dots, [x_n]) = \left[f(x_1, \dots, x_n)\right]$, но нужно доказать, что такие операции не будут зависеть от выбора $x_i$ в соответствующем классе, а это напрямую следует из 4 и 5 аксиом равенства. Получили, что

	Осталось доказать, что модель $M$ элементарно эквивалентна модели $\faktor{M}{\sim}$, тогда $\faktor{M}{\sim}$ автоматически будет нормальной моделью $T$. Для доказательства можно явно привести эпиморфизм моделей.

	Возьмем естественное отображение $x \rightarrow [x]$. Это отображение является гомоморфизмом из определения функциональных и предикатных символов на $\faktor{M}{\sim}$. Отображение сюръективно, так как классы эквивалентности не могут быть пустыми. Тогда это отображение \textemdash\ искомый эпиморфизм, модели элементарно эквивалентны, и $\faktor{M}{\sim}$ \textemdash\ нормальная модель $T$.
\end{proof}

\setcounter{section}{25}
\section{Игры Эренфойхта.}

Цель: сформулировать общий критерий
элементарной эквивалентности двух интерпретаций некоторой сигнатуры (считаем, что сигнатура содержит только предикатные символы).



Критерий будет сформулирован в терминах некоторой игры, называемой игрой Эренфойхта. В ней участвуют два игрока, называемые Новатором (Н) и Консерватором (К). Игра определяется выбранной парой интерпретаций.

В начале игры Новатор объявляет натуральное число $k$. Далее
они ходят по очереди, начиная с Н; каждый из игроков делает $k$ ходов, после чего определяется победитель.

На $i$-м ходу Н выбирает элемент в одной из интерпретаций (в
любой из двух) и помечает его числом i. В ответ К выбирает некоторый элемент из другой интерпретации и также помечает его числом i.

После k ходов игра заканчивается. При этом в каждой интерпретации k элементов оказываются помеченными числами от $1$ до $k$ (мы не учитываем, кто именно из игроков их пометил). Обозначим эти элементы
$a_1$, $a_2$, $\cdots$ , $a_k$ (для первой интерпретации)
и $b_1$, $b_2$, $\cdots$ , $b_k$ (для второй). Элементы $a_i$ и $b_i$ (с одним и тем же i) будем называть соответствующими друг другу.

Посмотрим, найдётся ли предикат сигнатуры, который различает помеченные элементы первой и второй интерпретации (то есть истинен на некотором наборе помеченных элементов в одной интерпретации, но ложен на соответствующих элементах другой). Если такой предикат найдётся, то выигрывает Новатор, в противном случае — Консерватор.

\begin{theorem}
Интерпретации не элементарно эквивалентны $\Longleftrightarrow$ Н имеет выигрышную стратегию в этой игре.
\end{theorem}

\begin{proof}

Докажем, что если Новатор имеет выигрышную стратегию, то интерпретации не элементарно эквивалентны.

Пусть есть различающая формула. Приведем ее к предваренной форме. Будем последовательно смотреть на кванторы в ее начале. Пусть текущий квантор - это $\exists$. Значит, есть элемент в $M_1$, для которого верна оставшаяся часть формулы, в то время как в $M_2$ такого нет. Этот элемент и должен выбрать Новатор очередным ходом.

Пусть текущий квантор - это $\forall$. В таком случае мы можем перейти к отрицанию и поступить аналогично шагу с $\exists$, только выбирая элемент в $M_2$.

Таким образом, за количество шагов, равное количеству кванторов в различающей формуле, Новатор может построить различающие наборы.

\end{proof}

\setcounter{section}{26}
\section{Семантически полные теории. Критерий семантической полноты теории в терминах эле-
ментарной эквивалентности моделей. Аксиоматизация элементарной теории упорядоченного
множества целых чисел.}

\begin{definition}\textit{Аксиоматическая теория T} - множество замкнутых формул.
\end{definition}

T \textit{семантически полна}, если для любой замкнутой формулы А выполнено одно из двух:
\begin{enumerate}
    \item из T семантически следует А (А истинно во всех моделях теории)
    \item из Т семантически следует $\neg A$
\end{enumerate}

\begin{lemma}
Теория семантически полна $\Longleftrightarrow$ любые 2 ее модели элементарно эквивалентны.
\end{lemma}
\begin{proof}

$\Rightarrow$ Элементарная эквивалентность значит, что в обоих моделях любая формула или истинна, или ложна. Тогда если $\phi$ следует из А, то она истинна для всех моделей, следовательно, для каждой пары. Аналогично для $\neg \phi$

$\Leftarrow$ От противного: какая-то формула сама не следует и ее отрицание не следует. Значит, есть модели, в одной из которых А истинно, в другой - ложно. Противоречие с элементарной эквивалентностью.

\end{proof}

\noindent\textbf{Аксиоматизация множества рациональных чисел}
\vspace{2mm}

$M = ( \mathbb{Q}, =, <)$
\begin{itemize}
    \item аксиомы равенства
    \begin{enumerate}
        \item $\forall x \: x = x$
        \item $\forall x \forall y \: x = y \rightarrow y = x$
        \item $\forall x \forall y \forall z \: \: x = y \land y = z \rightarrow x = z$
        \item $\forall x_1 \forall x_2 \forall y_1 \forall y_2 \: \: x_1 = x_2 \land y_1 = y_2 \rightarrow (x_1 = x_2 \rightarrow y_1 = y_2)$
    \end{enumerate}
    \item аксиомы линейного порядка
    \begin{enumerate}
        \item $x < y \land y < z \rightarrow x < z$
        \item $\neg \: (x < x)$
        \item $\forall x \forall y \: x < y \lor x > y \lor x = y$
    \end{enumerate}
    \item отсутствие наибольшего и наименьшего элемента
    \item плотность множества $\forall x, y \: (x < y \rightarrow \exists z \: \:  x < z \land z < y)$
\end{itemize}

\begin{theorem}{T - совместная и семантически полная.}
\begin{proof}
Доказательство аналогично игре Эренфойхта с $\mathbb{R}$ и$\mathbb{Q}$. Все выбранные в одной модели элементы идут в том же порядке, что и элементы второй модели. Консерватору достаточно возможности выбрать элемент между любыми двумя и отсутствие наибольшего и наименьшего элемента.
\end{proof}
\end{theorem}

\setcounter{section}{27}
\section{Аксиоматизация множества целых чисел.}

$M = (\mathbb{Z}, =, <)$
\begin{itemize}
    \item аксиомы равенства
    \item аксиомы линейного порядка
    \item отсутствие наибольшего и наименьшего элемента
    \item $\forall x \exists y (x < y \land \neg (\exists z \: \: x < z \land z < y))$
    \item $\forall x \exists y (x > y \land \neg (\exists z \: \: x > z \land z > y))$
\end{itemize}

\theorem{T - совместная и семантически полная.}
\begin{proof}
Как устроены модели Т? Это $\mathbb{Z}$, $\mathbb{Z}+\mathbb{Z}$ или любое множество вида AZ (А - линейно упорядоченное множество, в каждом элементе которого лежит множество целых чисел).
Скажем, что элементы эквивалентны, если мы можем получить один из другого за конечное число шагов. Факторизуем по этому отношению эквивалентности.
\end{proof}

\begin{lemma}Для любого линейно упорядоченного $A \: \: A  \mathbb{Z} \cong  \mathbb{Z}$
\begin{proof}
Доказывается аналогично случаю с $\mathbb{Z}+\mathbb{Z}$.
\end{proof}
\end{lemma}

\end{document}